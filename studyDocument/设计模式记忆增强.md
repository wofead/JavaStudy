# 设计模式  记忆增强
----------
3/4/2019 11: 27 :13 AM 
Author ： Jow
confuse and unsure is the direction, you are painful, but if you break from them you will get more. :smile::cry::heart::gift_heart:

---------
##1.  简单工厂模式  创造性模式
例子 ：计算器
运算基本类 继承运算基本类的具体计算类 加法 减法 乘法等等
 运算类工长 根据传递过来的操作符进行 运算类的构造 然后返回结果 
必要类：  基本类 继承基本类的具体类 以调用那个具体类的工厂 会使用switch函数


##2. 策略模式   行为型模式
商场打折
打折基本类 不同打折规则的具体类 例如打几折 满减等 
context上下文 用一个具体的策略来配置保持对它的引用 在构造函数中初始化，引用具体策略类
在打折的context中 可以结合工厂模式 使用switch 传入type来引用具体的策略 别忘记将方法也封装到context类中


**策略模式和简单工厂模式很像但还是存在区别的 **
* 用途不同
工厂是创建型模式，他的作用就是创建对象
策略是行为型模式，它的作用是一个对象在许多行为中选择一种行为，这些行为是可以相互替换的
* 关注点不同
一个关注对象的创建
一个关注行为的封装
* 解决不同的问题
工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。 
策略模式是为了解决的是策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。
* 工厂相当于黑盒子，策略相当于白盒子；

例子如上：计算器的关注点在应用不同的计算规则 计算规则的创建  打折在于选择不同的打折规则 他们是可以相互替换的

## 3. 单一职责原则
就一个类而言 应该只有一个引起它变化的原因
例子： 俄罗斯方块 一个n维数组 有方块填充变成1 无方块变成0 使用指针进行帧更新

## 4.依赖倒转原则
高层模块不应该依赖底层模块 两个都应该依赖抽象
抽象不应该依赖与细节  细节应该依赖于抽象
针对于接口编程，不要针对于实现编程
里氏代换原则：子类必须能够替换掉它们的父类型 只有子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能在父类的基础上增加新的行为。

针对于抽象编程而不是细节  程序中所有的依赖关系终止于抽象或者接口，那就是面向对象的设计，反之那就是过程化设计
## 5.装饰模式   结构型模式
动态给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加的灵活。
装饰模式利用设置组件来对对象进行封装，这样每个装饰对象的实现和如何使用这个对象分离开来，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链中。
baseComponent  -> concreteComponent -> decorator  继承关系
baseComponent  -> decorator -> concreteDerorator 继承关系
baseComponent  concreteComponent  decorator有操作函数  
concreteDerorator 多个行为方法
人穿衣服  
baseComponent名字和说出自己的名字
人 component
衣服  装饰 component  有一个装饰方法 记录装饰的组件
具体衣服 装饰

## 6. 代理模式
代理模式：为其他对象提供一种代理以控制对这个对象的访问
代理商和物主需要用统一接口链接 代理商榜物主做物主想做的事情
代理帮别人送礼物 
行为  花 书 贺卡 这些是接口 代理和物主都要拥有
追求者 代理 被追求者
追求者（被追求者）
代理（被追求者）  代理里面组合追求者 执行追求者的行为

## 7. 工厂方法模式
把简单工厂分割开来一个算法行成一个工厂  这样分支判断就不在简单工厂当中了而是在客户端当中
IFactory -> 加法工厂 等等
客户端调用方法
new 对应的工厂 然后调用create方法创建具体的对象

## 8. 原型模式
用原型实例制定创建对象的种类，并通过拷贝这些原型创建新的对象
即在对象中放置一个深拷贝方法 用来返回新的对象实例  在Java中clone() 就是深拷贝

## 9. 模板方法你是 
定义一个操作中的算法骨架，而将一些不走延迟刀子类中。模板方法使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。

选择题 每个人都做除了答案不同其它都一样

所以将获取答案的方法提炼出来形成抽象函数 有子类进行填充

function question()  answer + getAnswer()
abstract function getAnswer() return "a"

## 10.迪米特法则
如果两个雷不必彼此直接通信，那么这两个雷就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的话，可以通过第三者转发这个调用。
## 11. 外观模式
为子系统中的一组接口提供一个一致的界面，次莫属定义了一个高层接口，这个接口是的这一子系统更加容易使用。

facede类 关联各个子系统 然后实现不同方法来表现不同子系统想在特定情况想要表现出来的
用法：
1. 设计初期阶段，注意有意识的讲不通的两个层分离，层与层之间建立外观facade
2. 开发阶段，子系统往往因为不断的重构演化而变得越来越复杂。增加facade可以提供简单的接口，减少他们之间的依赖。
3. 在维护一个大型遗留系统的时候，当旧系统已经非常难以扩展的时候，为新系统开发一个新的外观类，来提供设计粗糙或高复杂的遗留代码的比较简单清晰简单接口。


## 12. 建造者模式
builder -> concreteBuilder director product 
director 指挥建造者生产产品 然后不同的生产者针对自己要做的产品添加组件组装产品

#13. 观察者模式
数据发生变化 通知视图层更新界面 这就是观察者模式
在游戏中事件的添加和管理就是明显观察者模式的应用  Java可以直接调用观察者模式
Java中有观察者模式的接口  observer  接口是观察者  Observable 是被观察者  注意数据改变要调用setChanged这样你通知才能改变数据

#14.抽象工厂模式
抽象工厂模式在工厂方法模式的基础上在具体的工厂里面添加属于其属性的工厂 组成工厂组 用来替换
数据库的替换 操作不同在操作哪里构造工厂，将各种操作放在工厂里作为集合传递出来

##15. 状态模式
状态模式，对一个队形的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
状态模式主要要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。
工作与状态  每个人在不同时间段的状态
## 16.适配器模式
将一个类的接口转换成客户希望的另一个接口。adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
外籍球员和本土球员 布置战术翻译需要将战术翻译给外籍球员
所以在交流方面 外籍球员还要依赖一层翻译
## 17.备忘录模式
游戏角色 角色状态存储箱 角色状态管理者
## 18.组合模式
即树状图 从root开始 每个节点都有父节点和子节点 一层一层
## 19.迭代器模式
提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示
售票员和乘客 乘客是聚集类 售票员作为迭代器
list 即是迭代器模式
## 20.单列模式
在程序中有且只存在这一个实例
使用静态记录自身是否被实例化过 没有实例化 有直接调用
还有多线程的单列模式记得加锁 同步
加锁保证一个县城位于代码的临界区时，另一个线程不进入临界区。
## 21 桥接模式
合成/聚合复用原则
尽量使用聚合和组合 而不是使用继承
将抽象部分与它的实现部分分离，使他们都可以独立的变化
手机 不同的手机品牌 
游戏 同一游戏不同平台
手机组合游戏 让这款游戏可以在手机上完
## 



